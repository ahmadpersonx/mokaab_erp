import 'package:flutter/foundation.dart';
// FileName: lib/features/finance/services/finance_service.dart
// Revision: 10.0 (Schema Aligned: Fixed column names matching Supabase DB)
// Date: 2025-12-20

import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../core/services/supabase_service.dart';
import '../../../core/models/definition_model.dart';

// Models
import '../models/journal_entry_model.dart';
import '../../../core/models/account.dart';
import '../../../core/models/voucher.dart';
import '../../../core/models/bank.dart';
import '../models/cost_center_model.dart';
import '../../../core/services/settings_service.dart'; // ✅ استيراد خدمة الإعدادات

class FinanceService {
  final SupabaseClient supabase = SupabaseService.client;
  final SettingsService _settings = SettingsService(); // ✅ إنشاء نسخة من الخدمة

  // --- Auth ---
  Future<AuthResponse> signIn(String email, String password) async {
    return await supabase.auth.signInWithPassword(email: email, password: password);
  }

  Future<void> signOut() async {
    await supabase.auth.signOut();
  }

  Future<Map<String, dynamic>?> getCurrentUserProfile() async {
    final user = supabase.auth.currentUser;
    if (user == null) return null;
    try {
      return await supabase.from('profiles').select().eq('id', user.id).single();
    } catch (e) {
      return {'full_name': 'Admin', 'role': 'admin'};
    }
  }

  Future<List<Map<String, dynamic>>> getAllUsers() async {
    final response = await supabase.from('profiles').select();
    return List<Map<String, dynamic>>.from(response);
  }

  Future<void> loadUserPermissions() async {}
  bool hasPermission(String permission) => true;

  // --- Accounts ---
  Future<List<Account>> getAllAccounts() async {
    try {
      final response = await supabase.from('accounts').select().order('code', ascending: true);
      return (response as List).map((e) => Account.fromJson(e)).toList();
    } catch (e) {
      return [];
    }
  }

  Future<void> addAccount(dynamic accountData) async {
    final data = (accountData is Account) ? accountData.toJson() : accountData;
    // Schema note: 'id' is generated by default as identity, usually we don't send it on insert unless necessary
    // But 'code' is the PK.
    if (data['id'] == 0) {
      data.remove('id');
    }
    await supabase.from('accounts').insert(data);
  }

  Future<void> updateAccount(int id, dynamic accountData) async {
    final data = (accountData is Account) ? accountData.toJson() : accountData;
    await supabase.from('accounts').update(data).eq('id', id);
  }

  Future<void> upsertAccounts(List<Map<String, dynamic>> accountsData) async {
    // The `upsert` method will insert new rows or update existing ones
    // based on the primary key conflict (which is 'code' for the 'accounts' table).
    // This is ideal for importing from Excel.
    await supabase.from('accounts').upsert(accountsData);
  }

  Future<void> deleteAccount(int id) async {
    await supabase.from('accounts').delete().eq('id', id);
  }

  /// جلب حسابات العملاء
  Future<List<Account>> getCustomerAccounts() async {
    try {
      // جلب الأكواد المصدر من الإعدادات
      final customerAccountSource = await _settings.get('vouchers_customer_account_source', defaultValue: '1231');
      final sourceCodes = customerAccountSource.split(',').map((e) => e.trim()).where((e) => e.isNotEmpty).toList();

      if (sourceCodes.isEmpty) return [];

      // بناء استعلام OR لكل كود مصدر
      // مثال: code.ilike.1231%,code.ilike.1232%
      final orQuery = sourceCodes.map((code) => 'code.ilike.$code%').join(',');

      // نجلب كل الحسابات التي تبدأ بهذا الرمز وتكون قابلة للترحيل
      final response = await supabase
          .from('accounts')
          .select()
          .or(orQuery)
          .eq('is_transaction', true) // Only transactional accounts
          .order('code', ascending: true);
          
      return (response as List).map((e) => Account.fromJson(e)).toList();
    } catch (e) {
      print('خطأ في جلب حسابات العملاء: $e');
      return [];
    }
  }

  /// جلب حسابات الصندوق (نقدي)
  Future<List<Account>> getCashBoxAccounts() async {
    try {
      final cashAccountSource = await _settings.get('vouchers_cash_account_source', defaultValue: '1211');
      final sourceCodes = cashAccountSource.split(',').map((e) => e.trim()).where((e) => e.isNotEmpty).toList();

      if (sourceCodes.isEmpty) return [];
      final orQuery = sourceCodes.map((code) => 'code.ilike.$code%').join(',');
      
      debugPrint('Fetching CashBox Accounts with query: $orQuery');

      final response = await supabase
          .from('accounts')
          .select()
          .or(orQuery)
          .eq('is_transaction', true);
      return (response as List)
          .map((acc) => Account.fromJson(acc))
          .toList();
    } catch (e) {
      print('خطأ في جلب حسابات الصندوق: $e');
      return [];
    }
  }

  /// جلب حسابات البنك
  Future<List<Account>> getBankAccounts() async {
    try {
      final bankAccountSource = await _settings.get('vouchers_bank_account_source', defaultValue: '1212');
      final sourceCodes = bankAccountSource.split(',').map((e) => e.trim()).where((e) => e.isNotEmpty).toList();

      if (sourceCodes.isEmpty) return [];
      final orQuery = sourceCodes.map((code) => 'code.ilike.$code%').join(',');
      
      debugPrint('Fetching Bank Accounts with query: $orQuery');

      final response = await supabase
          .from('accounts')
          .select()
          .or(orQuery)
          .eq('is_transaction', true);
      return (response as List)
          .map((acc) => Account.fromJson(acc))
          .toList();
    } catch (e) {
      print('خطأ في جلب حسابات البنك: $e');
      return [];
    }
  }

  // --- Cost Centers ---
  Future<List<CostCenterModel>> getAllCostCenters() async {
    try {
      final response = await supabase.from('cost_centers').select();
      return (response as List).map((e) => CostCenterModel.fromJson(e)).toList();
    } catch (e) {
      return [];
    }
  }

  // --- Journal Entries ---
  Future<Map<String, dynamic>> getJournalEntriesSummary() async {
    // يمكن تنفيذ استعلام تجميعي هنا لاحقاً
    return {'count': 0, 'total_debit': 0.0, 'total_credit': 0.0};
  }

  Future<List<JournalEntryModel>> getFilteredJournalEntries({DateTime? from, DateTime? to}) async {
    var query = supabase.from('journal_entries').select('*, journal_entry_lines(*)'); // لاحظ اسم الجدول الصحيح للأسطر
    
    if (from != null) query = query.gte('entry_date', from.toIso8601String()); // استخدم entry_date حسب السكيما
    if (to != null) query = query.lte('entry_date', to.toIso8601String());
    
    try {
      final response = await query;
      // نحتاج لتحويل journal_entry_lines إلى journal_lines ليتوافق مع الموديل إذا اختلف الاسم
      // أو تحديث الموديل. هنا سنفترض أن الموديل يتوقع الحقول كما هي أو نقوم بعمل map بسيط
      final modifiedResponse = (response as List).map((e) {
        e['journal_lines'] = e['journal_entry_lines']; // Mapping for Model compatibility
        return e;
      }).toList();
      
      return modifiedResponse.map((e) => JournalEntryModel.fromJson(e)).toList();
    } catch (e) {
      return [];
    }
  }

  Future<JournalEntryModel?> getJournalEntryByNumber(String number) async {
    try {
      final response = await supabase.from('journal_entries').select('*, journal_entry_lines(*)').eq('entry_number', number).single();
      response['journal_lines'] = response['journal_entry_lines'];
      return JournalEntryModel.fromJson(response);
    } catch (e) {
      return null;
    }
  }

  Future<void> saveJournalEntry(dynamic entryData) async {
    Map<String, dynamic> data = (entryData is JournalEntryModel) ? entryData.toJson() : entryData;
    // إزالة الحقول التي قد لا تكون في جدول الـ header مباشرة إذا لزم الأمر
    await supabase.from('journal_entries').insert(data);
  }

  Future<void> updateJournalEntry(int id, dynamic entryData) async {
    Map<String, dynamic> data = (entryData is JournalEntryModel) ? entryData.toJson() : entryData;
    await supabase.from('journal_entries').update(data).eq('id', id);
  }

  Future<List<Bank>> getBanks() async {
    try {
      // ✅ تصحيح: استخدام SettingsService لجلب مصدر قائمة البنوك
      final bankListSource = await _settings.get('vouchers_check_banks_source', defaultValue: 'banks');

      final response = await supabase
          .from('system_definitions')
          .select('id, code, name_ar, is_active') // تحديد الحقول المطلوبة
          .eq('type', bankListSource)
          .eq('is_active', true);
      
      return (response as List).map((bank) {
        return Bank(
          // استخدام البيانات من system_definitions
          id: bank['id'],
          code: bank['code'] ?? '',
          nameAr: bank['name_ar'] ?? '',
          isActive: bank['is_active'] ?? true,
        );
      }).toList();
    } catch (e) {
      print('خطأ في جلب البنوك: $e');
      return [];
    }
  }

  Future<String> generateVoucherNumber(String type) async {
    try {
      final today = DateTime.now();
      final prefix = _getVoucherPrefix(type);
      final datePrefix = '${today.year}${today.month.toString().padLeft(2, '0')}';

      final response = await supabase
          .from('vouchers')
          .select('voucher_number')
          .ilike('voucher_number', '$prefix-$datePrefix%')
          .order('id', ascending: false)
          .limit(1);

      int nextNumber = 1;
      if (response.isNotEmpty) {
        final lastNumber = response[0]['voucher_number'] as String;
        final parts = lastNumber.split('-');
        if (parts.length == 3) {
          nextNumber = int.parse(parts[2]) + 1;
        }
      }

      return '$prefix-$datePrefix-${nextNumber.toString().padLeft(3, '0')}';
    } catch (e) {
      print('خطأ في توليد رقم الحوالة: $e');
      return 'ERR-${DateTime.now().millisecondsSinceEpoch}';
    }
  }

  String _getVoucherPrefix(String type) {
    switch (type) {
      case 'receipt':
        return 'RCP';
      case 'payment':
        return 'DSB'; // Disbursement
      default:
        return 'VCH';
    }
  }

  Future<Voucher?> getVoucherByNumber(String voucherNumber) async {
    try {
      final response = await supabase
          .from('vouchers')
          .select('*, voucher_lines(*, accounts(*))')
          .eq('voucher_number', voucherNumber)
          .single();
      return Voucher.fromJson(response);
    } catch (e) {
      return null;
    }
  }

  Future<Voucher?> createVoucher({
    required String voucherNumber,
    required String type,
    required DateTime date,
    required String paymentMethod,
    required String treasuryAccountCode,
    required String description,
    required double amount,
    required List<Map<String, dynamic>> lines,
    String? checkNo,
    DateTime? checkDueDate,
    String? bankName,
    int? bankId,
  }) async {
    try {
      final voucherData = {
        'voucher_number': voucherNumber,
        'type': type,
        'date': date.toIso8601String().split('T')[0],
        'payment_method': paymentMethod,
        'treasury_account_id': treasuryAccountCode,
        'description': description,
        'amount': amount,
        'check_no': checkNo,
        'check_due_date': checkDueDate?.toIso8601String().split('T')[0],
        'bank_name': bankName,
        'bank_id': bankId,
        'check_status': paymentMethod == 'check' ? 'pending' : null,
        'created_by': supabase.auth.currentUser?.id,
      };

      final response = await supabase.from('vouchers').insert(voucherData).select().single();
      final voucherId = response['id'];

      for (var line in lines) {
        await supabase.from('voucher_lines').insert({'voucher_id': voucherId, ...line});
      }

      return await getVoucherByNumber(voucherNumber);
    } catch (e) {
      print('خطأ في إنشاء الحوالة: $e');
      rethrow;
    }
  }

  // --- Vouchers (تصحيح أسماء الأعمدة) ---
  Future<List<Map<String, dynamic>>> getVouchers({
    required String type, // 'receipt' or 'payment' - stored in 'type' column
    DateTime? fromDate,
    DateTime? toDate,
  }) async {
    try {
      var query = supabase
          .from('vouchers')
          .select('*, voucher_lines(*, accounts(*))') // Fetch lines and nested accounts
          .eq('type', type); // العمود اسمه type في السكيما

      if (fromDate != null) query = query.gte('date', fromDate.toIso8601String());
      if (toDate != null) query = query.lte('date', toDate.toIso8601String());

      final response = await query.order('date', ascending: false);
      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      return [];
    }
  }

  Future<void> updateVoucher(String voucherNumber, Map<String, dynamic> voucherData) async {
    final updateData = Map<String, dynamic>.from(voucherData);
    
    // تنظيف البيانات للأعمدة الصحيحة
    updateData.remove('account_id'); 
    if (updateData.containsKey('ref_number')) {
      updateData['check_no'] = updateData.remove('ref_number');
    }
    if (updateData.containsKey('voucher_type')) {
      updateData['type'] = updateData.remove('voucher_type');
    }

    await supabase.from('vouchers').update(updateData).eq('voucher_number', voucherNumber);
    
    // ملاحظة: تحديث الأسطر يتطلب منطقاً أكثر تعقيداً (حذف وإضافة، أو تحديث)، 
    // للتبسيط هنا نحدث الرأس فقط.
  }

  // --- Checks ---
  Future<List<Map<String, dynamic>>> getChecks({String status = 'all'}) async {
    // الجدول اسمه checks في السكيما غير موجود، ربما تقصد الفلترة من vouchers حيث check_no ليس null
    // بناءً على السكيما: لا يوجد جدول checks منفصل، الشيكات جزء من vouchers
    var query = supabase.from('vouchers').select().not('check_no', 'is', null);
    
    if (status != 'all') {
       query = query.eq('check_status', status);
    }
    
    final response = await query;
    return List<Map<String, dynamic>>.from(response);
  }

  // --- Definitions ---
  Future<List<Map<String, dynamic>>> getDefinitionTypes() async {
    final response = await supabase.from('definition_types').select();
    return List<Map<String, dynamic>>.from(response);
  }
  
  Future<void> createDefinitionType({required String code, required String nameAr, required Map<String, dynamic> config}) async {
    await supabase.from('definition_types').insert({'code': code, 'name_ar': nameAr, 'field_config': config});
  }

  Future<void> updateDefinitionType({required String code, required String nameAr, required Map<String, dynamic> config}) async {
    await supabase.from('definition_types').update({'name_ar': nameAr, 'field_config': config}).eq('code', code);
  }

  Future<void> deleteDefinitionType(String code) async {
    await supabase.from('definition_types').delete().eq('code', code);
  }

  Future<List<DefinitionModel>> getDefinitions(String type) async {
    // الجدول اسمه system_definitions حسب السكيما
    final response = await supabase.from('system_definitions').select().eq('type', type);
    return (response as List).map((e) => DefinitionModel.fromJson(e)).toList();
  }
  
  Future<List<Map<String, dynamic>>> getDefinitionsByType(String type) async {
     final response = await supabase.from('system_definitions').select().eq('type', type);
     return List<Map<String, dynamic>>.from(response);
  }

  Future<void> addDefinition(DefinitionModel item) async {
    await supabase.from('system_definitions').insert(item.toJson());
  }
  
  Future<void> createDefinitionItem(Map<String, dynamic> data) async {
    await supabase.from('system_definitions').insert(data);
  }

  Future<void> updateDefinition(DefinitionModel item) async {
    await supabase.from('system_definitions').update(item.toJson()).eq('id', item.id);
  }
  
  Future<void> updateDefinitionItem(int id, Map<String, dynamic> data) async {
    await supabase.from('system_definitions').update(data).eq('id', id);
  }

  Future<void> deleteDefinition(int id) async {
    await supabase.from('system_definitions').delete().eq('id', id);
  }
  
  Future<void> deleteDefinitionItem(int id) async {
    await supabase.from('system_definitions').delete().eq('id', id);
  }
  
  Future<void> updateUserPermissions(String userId, List<String> permissions) async {
    await supabase.from('user_permissions').delete().eq('user_id', userId);
    if (permissions.isNotEmpty) {
      final data = permissions.map((p) => {'user_id': userId, 'permission_code': p}).toList();
      await supabase.from('user_permissions').insert(data);
    }
  }
  
  Future<List<Map<String, dynamic>>> getAllPermissionDefinitions() async {
    final response = await supabase.from('permissions_def').select();
    return List<Map<String, dynamic>>.from(response);
  }
}